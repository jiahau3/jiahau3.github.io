<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Building a MA Crossing Strategy and Backtesting with Backtrader and VectorBT | JH&#39;s Notes</title>
<meta name="keywords" content="BackTrader, VectorBT, Trading">
<meta name="description" content="While on the road of learning algorithmic trading, backtesting provides a safe and efficient way to examine the performance of strategies. In this article, I would like to share my experience of testing a trend following strategy through different approaches.
A smooth mean average(SMA) crossover strategy is implemented on the historical data of BTC-BUSD asset. The trading logic is when the fast line of price crossing the slow line of price from below, a buy signal is on.">
<meta name="author" content="Jia-Hau Ching">
<link rel="canonical" href="https://jiahau3.github.io/posts/ma_strategy/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css" integrity="sha256-v1&#43;fc88XMR1SztvNqCySLpGy9WbYioWtn1taCLWGvV8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://jiahau3.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jiahau3.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jiahau3.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jiahau3.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://jiahau3.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Building a MA Crossing Strategy and Backtesting with Backtrader and VectorBT" />
<meta property="og:description" content="While on the road of learning algorithmic trading, backtesting provides a safe and efficient way to examine the performance of strategies. In this article, I would like to share my experience of testing a trend following strategy through different approaches.
A smooth mean average(SMA) crossover strategy is implemented on the historical data of BTC-BUSD asset. The trading logic is when the fast line of price crossing the slow line of price from below, a buy signal is on." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jiahau3.github.io/posts/ma_strategy/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-02T13:46:50+08:00" />
<meta property="article:modified_time" content="2022-07-02T13:46:50+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Building a MA Crossing Strategy and Backtesting with Backtrader and VectorBT"/>
<meta name="twitter:description" content="While on the road of learning algorithmic trading, backtesting provides a safe and efficient way to examine the performance of strategies. In this article, I would like to share my experience of testing a trend following strategy through different approaches.
A smooth mean average(SMA) crossover strategy is implemented on the historical data of BTC-BUSD asset. The trading logic is when the fast line of price crossing the slow line of price from below, a buy signal is on."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://jiahau3.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Building a MA Crossing Strategy and Backtesting with Backtrader and VectorBT",
      "item": "https://jiahau3.github.io/posts/ma_strategy/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Building a MA Crossing Strategy and Backtesting with Backtrader and VectorBT",
  "name": "Building a MA Crossing Strategy and Backtesting with Backtrader and VectorBT",
  "description": "While on the road of learning algorithmic trading, backtesting provides a safe and efficient way to examine the performance of strategies. In this article, I would like to share my experience of testing a trend following strategy through different approaches.\nA smooth mean average(SMA) crossover strategy is implemented on the historical data of BTC-BUSD asset. The trading logic is when the fast line of price crossing the slow line of price from below, a buy signal is on.",
  "keywords": [
    "BackTrader", "VectorBT", "Trading"
  ],
  "articleBody": "While on the road of learning algorithmic trading, backtesting provides a safe and efficient way to examine the performance of strategies. In this article, I would like to share my experience of testing a trend following strategy through different approaches.\nA smooth mean average(SMA) crossover strategy is implemented on the historical data of BTC-BUSD asset. The trading logic is when the fast line of price crossing the slow line of price from below, a buy signal is on. Vice versa, the sell signal is on when fast one crossing slow one from above. 10 day’s average price(sma10) is used as fast line, and 20 day’s average price(sma20) is for slow line.\nLet’s try to achieve this strategy from basic packages. Taking advantage of Pandas.DataFrame rolling method, the values of two lines are calculated.\nprice_btc['close_sma10'] = price_btc['Close'].rolling(10).mean() price_btc['close_sma20'] = price_btc['Close'].rolling(20).mean() The signals are appeared when these two values crossing. I just assign a boolean value when sma10 is greater than sma20. This results in a column containing 0 and 1. The trading signals are located in the transition between 0 and 1 dates. These can be obtained by substracting the boolean column with its one-day shift value.\nprice_btc['c10_High'] = np.where(price_btc['close_sma10'] \u003e price_btc['close_sma20'], 1, 0) price_btc['signals'] = np.where((price_btc['c10_High'] - price_btc['c10_High'].shift(1)) == 1, 1, 0) price_btc['signals'] = np.where((price_btc['c10_High'] - price_btc['c10_High'].shift(1)) == -1, -1, price_btc['signals']) After getting the signals, we have to add the a boolen column to represent the status of our position. It is 1 for holding the asset. Vice versa.\nposition = np.zeros(price_btc.shape[0]) for i in range(price_btc.shape[0]): if price_btc['signals'][i] == 1: position[i:] += 1 if (price_btc['signals'][i] == -1) \u0026 (position[i] == 1): position[i:] -= 1 To calculate the cumulative return, it is simply multiplying the daily return with the corresponding position.\nprice_btc['return'] = price_btc['Close'].pct_change() price_btc['position'] = pd.Series(position, index=price_btc.index).shift(1) price_btc['strategy_return'] = price_btc['return'] * price_btc['position'] Plotting the result for checking if it is executed as expected.\nThe strategy is successfully executed!\nThe profit of this strategy is 248%.\nLet’s compare it with backtesting package, VectorBT and Backtrader. VectorBT is fairly straightforward to implement, and fast especially for backtesting multiple strategies.\nimport vectorbt as vbt price = price_btc['Close'] pf = vbt.Portfolio.from_holding(price, init_cash=100) fast_ma = vbt.MA.run(price, 10) slow_ma = vbt.MA.run(price, 20) entries = fast_ma.ma_crossed_above(slow_ma) exits = fast_ma.ma_crossed_below(slow_ma) pf = vbt.Portfolio.from_signals(price, entries, exits, init_cash=100) pf.total_profit() 248.0714028499914 It works quite similar to Pandas. By using the methods, It gives the same profit as calculated above.\nHere is the plot. It contains PnL for each trade. Backtrader might be a more realistic test for trading I think. While giving the same condition to Backtrader, some trades are failed to execute due to lacking enough money. Putting 100% of portfolio for each trade results in cancellation of order occasionally. I have to adjust the trading size of portfolio in order to mimic the trade results above.\nThe result from Backtrader is: And that’s it! I briefly work through these 3 methods for implementing a trading strategy. Hopefully this article provides some insights for your trading journey! Here is the link of the code if you feel like digging deeper. Also a video is provided for explaining the notebook.\n",
  "wordCount" : "519",
  "inLanguage": "en",
  "datePublished": "2022-07-02T13:46:50+08:00",
  "dateModified": "2022-07-02T13:46:50+08:00",
  "author":[{
    "@type": "Person",
    "name": "Jia-Hau Ching"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jiahau3.github.io/posts/ma_strategy/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "JH's Notes",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jiahau3.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jiahau3.github.io/" accesskey="h" title="JH&#39;s Notes (Alt + H)">
                <img src="https://jiahau3.github.io/static/images/icons8-adventure-64.png" alt="" aria-label="logo"
                    height="30">JH&#39;s Notes</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jiahau3.github.io/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://jiahau3.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://jiahau3.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Building a MA Crossing Strategy and Backtesting with Backtrader and VectorBT
    </h1>
    <div class="post-meta"><span title='2022-07-02 13:46:50 +0800 CST'>July 2, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Jia-Hau Ching

</div>
  </header> 
  <div class="post-content"><p>While on the road of learning algorithmic trading, backtesting provides a safe and efficient way to examine the performance of strategies. In this article, I would like to share my experience of testing a trend following strategy through different approaches.</p>
<p>A smooth mean average(SMA) crossover strategy is implemented on the historical data of BTC-BUSD asset. The trading logic is when the fast line of price crossing the slow line of price from below, a buy signal is on. Vice versa, the sell signal is on when fast one crossing slow one from above. 10 day&rsquo;s average price(sma10) is used as fast line, and 20 day&rsquo;s average price(sma20) is for slow line.</p>
<p>Let&rsquo;s try to achieve this strategy from basic packages. Taking advantage of Pandas.DataFrame rolling method, the values of two lines are calculated.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>price_btc[<span style="color:#e6db74">&#39;close_sma10&#39;</span>] <span style="color:#f92672">=</span> price_btc[<span style="color:#e6db74">&#39;Close&#39;</span>]<span style="color:#f92672">.</span>rolling(<span style="color:#ae81ff">10</span>)<span style="color:#f92672">.</span>mean()
</span></span><span style="display:flex;"><span>price_btc[<span style="color:#e6db74">&#39;close_sma20&#39;</span>] <span style="color:#f92672">=</span> price_btc[<span style="color:#e6db74">&#39;Close&#39;</span>]<span style="color:#f92672">.</span>rolling(<span style="color:#ae81ff">20</span>)<span style="color:#f92672">.</span>mean()
</span></span></code></pre></div><p>The signals are appeared when these two values crossing. I just assign a boolean value when sma10 is greater than sma20. This results in a column containing 0 and 1. The trading signals are located in the transition between 0 and 1 dates. These can be obtained by substracting the boolean column with its one-day shift value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>price_btc[<span style="color:#e6db74">&#39;c10_High&#39;</span>] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>where(price_btc[<span style="color:#e6db74">&#39;close_sma10&#39;</span>] <span style="color:#f92672">&gt;</span> price_btc[<span style="color:#e6db74">&#39;close_sma20&#39;</span>], <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>price_btc[<span style="color:#e6db74">&#39;signals&#39;</span>] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>where((price_btc[<span style="color:#e6db74">&#39;c10_High&#39;</span>] <span style="color:#f92672">-</span> price_btc[<span style="color:#e6db74">&#39;c10_High&#39;</span>]<span style="color:#f92672">.</span>shift(<span style="color:#ae81ff">1</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>price_btc[<span style="color:#e6db74">&#39;signals&#39;</span>] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>where((price_btc[<span style="color:#e6db74">&#39;c10_High&#39;</span>] <span style="color:#f92672">-</span> price_btc[<span style="color:#e6db74">&#39;c10_High&#39;</span>]<span style="color:#f92672">.</span>shift(<span style="color:#ae81ff">1</span>)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, price_btc[<span style="color:#e6db74">&#39;signals&#39;</span>])
</span></span></code></pre></div><p>After getting the signals, we have to add the a boolen column to represent the status of our position. It
is 1 for holding the asset. Vice versa.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>position <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(price_btc<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(price_btc<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> price_btc[<span style="color:#e6db74">&#39;signals&#39;</span>][i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        position[i:] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (price_btc[<span style="color:#e6db74">&#39;signals&#39;</span>][i] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> (position[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        position[i:] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>To calculate the cumulative return, it is simply multiplying the daily return with the corresponding position.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>price_btc[<span style="color:#e6db74">&#39;return&#39;</span>] <span style="color:#f92672">=</span> price_btc[<span style="color:#e6db74">&#39;Close&#39;</span>]<span style="color:#f92672">.</span>pct_change()
</span></span><span style="display:flex;"><span>price_btc[<span style="color:#e6db74">&#39;position&#39;</span>] <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>Series(position, index<span style="color:#f92672">=</span>price_btc<span style="color:#f92672">.</span>index)<span style="color:#f92672">.</span>shift(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>price_btc[<span style="color:#e6db74">&#39;strategy_return&#39;</span>] <span style="color:#f92672">=</span> price_btc[<span style="color:#e6db74">&#39;return&#39;</span>] <span style="color:#f92672">*</span> price_btc[<span style="color:#e6db74">&#39;position&#39;</span>]
</span></span></code></pre></div><p>Plotting the result for checking if it is executed as expected.</p>
<p><img loading="lazy" src="/images/MA_cross.png" alt="MA crossing"  title="MA crossing strategy: Execute the trade when two lines crossed, y-axis is BTC price"  />
</p>
<p><img loading="lazy" src="/images/return_compare.png" alt="Return compare"  title="Cumulative return comparison of Buy&amp;Hold vs. MA crossing"  />
</p>
<p>The strategy is successfully executed!</p>
<p>The profit of this strategy is 248%.</p>
<p>Let&rsquo;s compare it with backtesting package, VectorBT and Backtrader. VectorBT is fairly straightforward to implement, and fast especially for backtesting multiple strategies.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">import</span> vectorbt <span style="color:#66d9ef">as</span> vbt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>price <span style="color:#f92672">=</span> price_btc[<span style="color:#e6db74">&#39;Close&#39;</span>]
</span></span><span style="display:flex;"><span>pf <span style="color:#f92672">=</span> vbt<span style="color:#f92672">.</span>Portfolio<span style="color:#f92672">.</span>from_holding(price, init_cash<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>fast_ma <span style="color:#f92672">=</span> vbt<span style="color:#f92672">.</span>MA<span style="color:#f92672">.</span>run(price, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>slow_ma <span style="color:#f92672">=</span> vbt<span style="color:#f92672">.</span>MA<span style="color:#f92672">.</span>run(price, <span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>entries <span style="color:#f92672">=</span> fast_ma<span style="color:#f92672">.</span>ma_crossed_above(slow_ma)
</span></span><span style="display:flex;"><span>exits <span style="color:#f92672">=</span> fast_ma<span style="color:#f92672">.</span>ma_crossed_below(slow_ma)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pf <span style="color:#f92672">=</span> vbt<span style="color:#f92672">.</span>Portfolio<span style="color:#f92672">.</span>from_signals(price, entries, exits, init_cash<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>pf<span style="color:#f92672">.</span>total_profit()
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">248.0714028499914</span>
</span></span></code></pre></div><p>It works quite similar to Pandas. By using the methods, It gives the same profit as calculated above.</p>
<p>Here is the plot. It contains PnL for each trade.
<img loading="lazy" src="/images/result_vbt.png" alt="VBT Result"  />

Backtrader might be a more realistic test for trading I think. While giving the same condition to Backtrader, some trades are failed to execute due to lacking enough money. Putting 100% of portfolio for each trade results in cancellation of order occasionally. I have to adjust the trading size of portfolio in order to mimic the trade results above.</p>
<p>The result from Backtrader is:
<img loading="lazy" src="/images/result_bt.png" alt="BT Result"  />

And that&rsquo;s it! I briefly work through these 3 methods for implementing a trading strategy. Hopefully this article provides some insights for your trading journey! Here is the <a href="https://github.com/jiahau3/Algorithmic_trading/blob/master/backtest_compare.ipynb">link</a> of the code if you feel like digging deeper. Also a <a href="https://www.youtube.com/watch?v=el0V-3Gb2rc">video</a> is provided for explaining the notebook.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://jiahau3.github.io/tags/backtrader/">BackTrader</a></li>
      <li><a href="https://jiahau3.github.io/tags/vectorbt/">VectorBT</a></li>
      <li><a href="https://jiahau3.github.io/tags/trading/">Trading</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://jiahau3.github.io/">JH&#39;s Notes</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
